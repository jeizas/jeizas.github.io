---
layout: post
title: "Java编程思想 - 第五章、初始化与清理"
date: 2016-05-05 09:34
categories: [java]
tags: [Java编程思想]
---

### 本章要点

> 随着计算机革命的发展，“不安全”的编程方式已逐步成为编程代价高昂的主因之一。**初始化**与**清理**正是涉及安全的两个问题。
> C++提出了构造函数和析构函数。为了提高执行效率，这两项工作均由程序员完成。而JAVA提供了构造函数供程序员初始化，并额外提供了垃圾回收器。虽然安全性有了保证，但是也牺牲了一定的效率。

#### 一、 用构造器初始化

* java中没有规定“每个方法首字母小写”的原因：构造器的名称必须与类名完全相同。
* 在java中，“初始化”和“创建”捆绑在一起，两者不能分离。也就是说：在调用构造器的时候完成了对象的创建和初始化。
* 方法重载：参数列表区分重载和返回值区分重载
* 默认构造器：你写的类中，如果没有构造器，则编译器会自动帮你创建一个默认构造器；如果已经定义了一个构造器（无论是否有参），编译器就不会帮你创建默认构造器。
* 初始化顺序：

{% highlight java linenos %}
package Chapter05;

class InitTest {
	public static int number = 2014;
    public int i; public int j = 3;

	InitTest(int i) {//构造器是static静态方法
    	this.i = i;
    	j = 10;
	}

	public void print() {
    	System.out.println(number);
    	System.out.println(i);
    	System.out.println(j);
	}
}

public class InitOrder{
	public static void main(String[] args){
    InitTest initTest = new InitTest(20);//重点讲解此句的含义
    initTest.print();
    }
}
{% endhighlight java %}

* 当首次创建类型InitTest的对象时，类的静态方法/静态域被访问时，java解释器查找类路径，以定位xxx.class文件。
* 然后使用classLoader载入InitTest.class，，有关静态初始化的所有动作都会执行，因此静态初始化只在class对象**首次加载**的时候进行一次,如果没有针对对象的new操作，初始化就完成了。接下来是创建对象才会触发的。
* 当用new InitTest(20)创建对象的时候，首先在堆上为对象分配足够的存储空间。
* 这块存储空间首先会被清零，自动将对象中的所有基本类型数据设置成默认值（对数字来说就是0，布尔和字符型也相同），引用初始化为null
* 执行所有出现于数据定义处的初始化动作
* 执行构造函数(继承相关的很多动作)


#### 二、 this关键字

* 类内部：假如A类有一个fun(int i)函数，可以写成this.fun(int i),但无此不要，因为编译器会自动帮我们添加，人们使用高级语言原因之一就是他们能帮我们做一些事情，要把this放到一些没必要的地方，会使读程序的人不知所措，因为别人写的代码不会到处使用this，只希望在必要的地方使用this，遵循一中一致而直观的编程风格能节省时间和金钱。
* 对象间：假如A类有一个fun(int i)函数，现在A类创建了2个对象，2个引用指向了这两个新对象，2个引用为a和b。那么a和b调用fun(int i)的时候，fun(int i)怎么区分哪个是a哪个是b呢？其实这个工作是通过this实现的。编译器在编译的时候，会把a.fun(1)和b.fun(2)转化成A.fun(a, 1)和A.fun(b, 2)的。当然，这是编译器在幕后做的，我们使用的时候不能写成这种形式。
* static再谈：static方法就是没有this的方法。是类的属性，与对象无关，它不存在“向对象发送消息”的方式来完成的。

#### 三、 清理：终结处理与垃圾回收

1. 对象可能不被垃圾回收
2. 垃圾回收并不等于“析构”
3. 垃圾回收只与内存有关

* 垃圾回收的唯一原因：为了回收JVM中程序不再使用的内存。所以对于垃圾回收有关的任何行为来说（尤其是finalize（）方法），他们必须同内存及其回收有关。
* 垃圾回收的方式：标记-清扫、停止-复制

