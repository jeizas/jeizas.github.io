---
layout: post
title: "JVM 浅谈"
date: 2016-04-08 12:35
categories: [java]
tags: [note]
---

### JVM 浅谈

一、 什么是JVM

> JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。

> Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。

二、 java内存区域

> java虚拟机在执行java程序的过程会把他所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建时间和销毁时间，有些区域随着虚拟机进程的启动二存在，有些区域则依赖用户线程的启动和结束而创建和销毁。根据规范，java虚拟机所有管理的内存包括一下几个运行时数据区域。

1. 程序计数器 
    - 是什么：一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器。
    - 用途：由于多线程宏观并行微观交替，因此，为了线程切换之后能恢复到之前正确的执行位置，每条线程都需要有一个独立的程序计数器来记录那些信息。
    - 存什么 
        * 线程执行java方法，这个计数器记录线程正在执行的虚拟机字节码指令地址

        * 线程执行的是Native方法，这个计数器值为空（Undefined）
    - 异常情况：唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
    - 参数：**待添加**

2. java虚拟机栈
	- 是什么：它描述的是java方法执行的内存模型，没法方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
	- 用途：每个方法调用到执行完成的过程，就对应着一个栈帧从虚拟机中入栈到出栈的过程。
	- 存什么：
		- 局部变量表：存放了编译期可知的各种基本数据类型和对象引用类型。运行期间所需的内存在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，运行期间不会改变变量表的大小。
		- 操作数栈：和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作—压栈和出栈—来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用；不同于程序计数器，Java虚拟机没有寄存器，程序计数器也无法被程序指令直接访问。Java虚拟机的指令是从操作数栈中而不是从寄存器中取得操作数的，因此它的运行方式是基于栈的而不是基于寄存器的。虽然指令也可以从其他地方取得操作数，比如从字节码流中跟随在操作码（代表指令的字节）之后的字节中或从常量池中，但是主要还是从操作数栈中获得操作数。
		- 动态链接：由于Java程序是运行在Java虚机之上的，自然的Java程序在运行过程中所需要加载的类文件或其他的资源文件都需要Java虚机来负责加载， 并提供管理和调用。有时候遇到’Exception in thread "main" java.lang.NoClassDefFoundError:XXX‘，一般遇到这个问题的时候，基本上都是因为你的CLASSPATH没有设置正确， 设置正确的CLASSPATH，就可以解决这个问题，首先我们来究其原因，我们知道Java虚机在运行的过程中是通过class loader动态读取Class文件，并将加载后Class的字节码交付给Java虚机执行。这个很容易理解，Java虚机不可能预先知道任意一个 Java程序需要的Class文件，所以Java虚机需要通过某种手段来实现Class文件的正常读写，上面的Exception就是Java虚机在加载 Class文件出现的。
		- 方法出口：方法返回地址，当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。

3. 本地方法区
	- 本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。

4. java堆
	- 是什么：对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。
	- 存储：如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为
		- 新生代：
			- Eden 空间：对象第一次分配存储区域
			- From Survivor 空间：Eden满后，发生gc剩下的对象
			- To Survivor 空间：gc前把空的Survivor放到非空
		- 老年代：Survivor满后放入此

5. 方法区
	- 方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。很多人愿意把方法区称为“永久代”（Permanent Generation）

6. 运行时常量池
	- 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern() 方法。

7. 直接内存
	- JDK 1.4 中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel），与缓冲区（Buffer）的I/O 方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。
	- 异常情况：一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。
